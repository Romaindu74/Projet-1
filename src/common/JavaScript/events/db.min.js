const { AES, CryptoJS } = require('../modules/aes.js');
const Zlib              = require('zlib');
const fs                = require('fs');

/**
 * @param {String} path 
 * @param {String} password 
 */
function open_db(path, password = undefined) {
    if (typeof path === 'undefined') {
        return [1, `L'élément "path" n'a pas été trouvé.`];
    }

    if (!fs.existsSync(`${path}/index.json`)) {
        return [1, `La base de données n'a pas été trouvée.`];
    }

    try {
        var index_file = JSON.parse(fs.readFileSync(`${path}/index.json`, 'utf8'));
    } catch {
        return [1, `La base de données contient une erreur.`];
    }

    if (index_file.password && typeof password === 'undefined') {
        return [1, `L'élément "password" n'a pas été trouvé.`];
    } else if (index_file.password && index_file.password !== password) {
        return [1, `Le mot de passe est incorrect.`];
    }

    var encoded_string = "";
    for (var file of index_file.files) {
        var encoded_content = fs.readFileSync(`${path}${file}`);
        var buffer          = Zlib.inflateSync(encoded_content);
        for (var i = 0; i < buffer.length; i++) {
            encoded_string += String.fromCharCode(buffer[i]);
        }
    }

    try {
        var decoded_string = AES.decrypt(encoded_string, index_file.key).toString(CryptoJS.enc.Utf8);
    } catch {
        return [1, `Une erreur s'est produite lors du décryptage des données.`];
    }

    return [0, decoded_string];
}

/**
 * 
 * @param {Events} event 
 * @param {Loop} loop 
 * @returns { Json }
 */
function open(event, loop) {
    const Clients = event.Clients;
    const Path    = `${Clients.path}/common/Json`;
    const Data    = event.data.data;

    if (typeof Data.path === "undefined") {
        return { error: `L'élément "path" n'a pas été trouvé.` };
    }

    var result = open_db(`${Path}/${Data.path}`, Data.password);

    if (result[0] == 1) {
        return { error: result[1] };
    }

    return { data: result[1] };
}

/**
 * 
 * @param {String} path 
 * @param {String} data 
 * @param {String} password 
 * @param {String} new_password 
 */
function save_db(path, data, password = undefined, new_password = undefined) {
    if (typeof path === 'undefined') {
        return [1, `L'élément "path" n'a pas été trouvé.`];
    }

    if (typeof data === 'undefined') {
        return [1, `L'élément "data" n'a pas été trouvé.`];
    } else if (typeof data !== 'string') {
        return [1, `Le type de l'élément 'data' doit être une chaîne de caractères.`];
    }

    if (!fs.existsSync(`${path}/index.json`)) {
        return [1, `La base de données n'a pas été trouvée.`];
    }

    try {
        var index_file = JSON.parse(fs.readFileSync(`${path}/index.json`, 'utf8'));
    } catch {
        return [1, `La base de données contient une erreur.`];
    }

    if (index_file.password && typeof password === 'undefined') {
        return [1, `L'élément "password" n'a pas été trouvé.`];
    } else if (index_file.password && index_file.password !== password) {
        return [1, `Le mot de passe est incorrect.`];
    }

    if (typeof new_password === "string") {
        index_file.password = new_password;
    }

    try {
        var encoded_string = AES.encrypt(data, index_file.key).toString();
    } catch {
        return [1, `Une erreur s'est produite lors de l'encodage des données.`];
    }

    const max_length = 1000000;

    var is_length    = "";
    var hash         = [];

    for (var i = 0; i < encoded_string.length; i++) {
        is_length += encoded_string[i];

        if (is_length.length === max_length) {
            hash.push(is_length);is_length = "";
        }
    }

    if (is_length !== "") {
        hash.push(is_length);
    }

    if (!fs.existsSync(`${path}/files/`)) {
        fs.mkdirSync(`${path}/files/`);
    }

    var before_files = index_file.files;
    index_file.files = [];
    for (var i = 0; i < hash.length; i++) {
        var buffer       = new Uint8Array(hash[i].split("").map(function(v){return v.charCodeAt(0)}));
        var encoded_zlib = Zlib.deflateSync(buffer);

        fs.writeFileSync(`${path}/files/${i}.json`, encoded_zlib, 'binary');
        index_file.files.push(`/files/${i}.json`);
    }

    if (before_files) {
        for (var file of before_files) {
            if (!index_file.files.includes(file)) {
                fs.unlinkSync(`${path}${file}`);
            }
        }
    }

    try {
        fs.writeFileSync(`${path}/index.json`, JSON.stringify(index_file, undefined, 4), 'utf8');
    } catch {
        return [1, `La base de données contient une erreur.`];
    }

    return [0, { saved: true }];
}

/**
 * 
 * @param {Events} event 
 * @param {Loop} loop 
 * @returns { Json }
 */
function save (event, loop) {
    const Clients = event.Clients;
    const Path    = `${Clients.path}/common/Json`;
    const Data    = event.data.data;

    var result = save_db(`${Path}/${Data.path}`, Data.data, Data.password, Data.newPassword);

    if (result[0] == 1) {
        return { error: result[1] };
    }

    return { data: result[1] };
}

/**
 * 
 * @param {Events} event 
 * @param {Loop} _
 * @returns { Json }
 */
function ls(event, _) {
    const Clients = event.Clients;
    var Path      = "";

    for (var p of `${Clients.path}/common/Json`.split('/')) {
        if (p != '') {
            Path += '/' + p;
        }
    }

    /**
     * @param {String} path 
     * @param {String} _ 
     * @returns {List}
     */
    function _ls(path, _) {
        var result = [];
        for (var file of fs.readdirSync(path)) {
            var stats = fs.statSync(`${path}/${file}`);
            if (!stats.isDirectory() && file == 'index.json') {
                result.push(path.replace(_, ''));
            } else if (stats.isDirectory()) {
                for (var r of _ls(`${path}/${file}`, _)){result.push(r)};
            }
        }
        return result;
    }

    return { data: _ls(Path, Path) };
}

/**
 * 
 * @param {Events} event 
 * @param {Loop} _
 * @returns { Json }
 */
function new_database (event, _) {
    const Clients = event.Clients;
    const Path    = `${Clients.path}/common/Json`;
    const Data    = event.data.data;

    if (typeof Data.path === "undefined") {
        return { error: `L'element "path", n'a pas été trouvé` };
    }
    var p = `${Path}/${Data.path}`;

    if (fs.existsSync(`${p}/index.json`)) {
        return { error: `Le fichier à créer existe déjà` };
    }

    try {
        fs.mkdirSync(`${p}/files/`, { recursive: true });
        var i = JSON.stringify({ files: [], key: "123456789" }, undefined, 4);
        fs.writeFileSync(`${p}/index.json`, i, 'utf8');
    } catch {
        return { error: `Le fichier n'a pas pu etre créer` }
    }

    var result = p.split(Path);
    return { data: { added: result[1] } };
}

/**
 * 
 * @param {Events} event 
 * @param {Loop} _
 * @returns { Json }
 */
function del_database (event, _) {
    const Clients = event.Clients;
    const Path    = `${Clients.path}/common/Json`;
    const Data    = event.data.data;

    if (typeof Data.path === "undefined") {
        return { error: `L'element "path", n'a pas été trouvé` };
    }
    var p = `${Path}/${Data.path}`;

    if (!fs.existsSync(`${p}/index.json`)) {
        return { error: `Le fichier demander n'existe pas` };
    }

    try {
        var i = fs.readFileSync(`${p}/index.json`, 'utf8');
        var index_file = JSON.parse(i);
    } catch {
        return { error: `Impossible de le supprimer` };
    }

    for (var file of index_file.files) {
        fs.unlinkSync(`${p}${file}`);
    }

    fs.unlinkSync(`${p}/index.json`);

    function remove(path) {
        if (fs.readdirSync(path).length == 0) {
            fs.rmdirSync(path);var p = path.split('/');while(p.pop()==''){};
            return remove(p.join('/'));
        } else {
            return true;
        }
    }
    
    return { data: { delete: Data.path, check: remove(`${p}/files/`)} };
}

exports.info = {
    "open": {
        func: open,
        version: "0.0.0.4"
    },
    "save": {
        func: save,
        version: "0.0.0.4"
    },
    "ls": {
        func: ls,
        version: "0.0.0.19"
    },
    "new": {
        func: new_database,
        version: "0.0.0.3"
    },
    "del": {
        func: del_database,
        version: "0.0.0.8"
    }
}