const Zlib = require('zlib');
const { AES, CryptoJS } = require('../modules/aes.js');

class Client {
    /**
     * @param {WebSocket.WebSocket} ws 
     * @param {String} path 
     * @param {String} key 
     * @param {Logs} logs
     */
    constructor (ws, path, key, logs) {
        this.ws   = ws;
        this.path = path;
        this.logs = logs;
        this.key  = key;
    }

    /**
     * @param {WebSocket.RowData} message 
     */
    message (message) {
        var data = message.toString();

        try {
            var buffer_decoded = Zlib.inflateSync(data);


            var encode_session = "";
            for (var i = 0; i < buffer_decoded.length; i++) {
                encode_session += String.fromCharCode(buffer_decoded[i]);
            }

        } catch (e) {
            var encode_session = data;
        }

        try {
            var decrypted = AES.decrypt(encode_session, this.key).toString(CryptoJS.enc.Utf8);
        } catch (e) {
            var decrypted = encode_session;
        }

        if (decrypted == '') {
            var decrypted = encode_session;
        }

        try {
            var json = JSON.parse(decrypted);
        } catch (e) {
            return this.logs.error(`Le message reçu n'a pas pu ếtre decodé.`);
        }

        return json;
    }

    /**
     * @param {Json} data 
     * @param {Bool} encoding
     */
    send (data, encoding = false) {
        try {
            var data = JSON.stringify(data);
        } catch {
            return
        }

        if (encoding) {
            try {
                var encrypted = AES.encrypt(data, this.key).toString();
            } catch (e) {
                return this.logs.error(`Le message ${data} n'a pas pu ếtre encodé.1`);
            }
        } else {
            var encrypted = data;
        }

        try {
            var buffer_encoded = Zlib.deflateSync(new Uint8Array(encrypted.split('').map(function(x){return x.charCodeAt(0)})));
        } catch (e) {
            return this.logs.error(`Le message ${data} n'a pas pu ếtre encodé.2`);
        }

        try {
            this.ws.send(buffer_encoded);
        } catch (e) {
            return this.logs.error(`Le message ${data} n'a pas pu ếtre encodé.`);
        }
    }
}

exports.Client = Client;